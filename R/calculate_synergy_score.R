# TidyComb
# Functions for calculating drug synergy scores.
#
# Functions in this page:
#
# CalculateSynergy: Calculate the synergy scores for drug combinations
# ZIP/Bliss/HSA/Loewe: 4 functions to calculate synergy scores.
# eq.LL4/L4.LL4/L4: 4 functions to calculate loewe score in CalculateLoewe.
# fun: Function used in CalculateLoewe

#' Calculate the synergy scores for drug combinations
#'
#' \code{CalculateSynergy} is the main function for calculating synergy scores
#' based on model(ZIP, Bliss, Loewe, and HSA) fron one dose-response 
#' \strong{matrix}.
#' 
#' @param data  a list object generated by function \code{\link{ReshapeData}}.
#' 
#' @param adjusted a logical value. If it is \code{TRUE}, the 
#'   'adjusted.response.mats' will be used to calculate synergy scores. If it is
#'   \code{FALSE}, the raw data ('dose.response.mats') will be used to calculate
#'   synergy scores.
#' 
#' @param method a parameter to specify which models to use to calculate the 
#'   synergy scores. Choices are "ZIP", "Bliss", "HSA" and "Loewe". Defaults to
#'   "ZIP".
#'
#' @return a list. It contains 4 elements:
#'   \itemize{
#'     \item \strong{dose.response.mats} The original input dose-response matrix
#'     \item \strong{adjusted.response.mats} The dose response matrix adjusted
#'       by functions: \code{\link{AddNoise}}, \code{\link{ImputeNA}}, and 
#'       \code{\link{CorrectBaseLine}}.
#'     \item \strong{drug.pairs} a data frame contains the name of the row drug,
#'     the name of the column drug, concentration unit and block IDs.
#'     \item \strong{scores} It contains the modified response value and 4
#'     type of synergy scores of each drug dose response pair.
#'     \item \strong{method} the method used to calculate the synergy scores.
#'  }
#'
#' @author 
#'   \itemize{
#'     \item Liye He \email{liye.he@helsinki.fi}
#'     \item Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'  }
#'
#' @export
#' 
#' @examples 
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' scores <- CalculateSynergy(data)
CalculateSynergy <- function(data, method="ZIP", adjusted = TRUE) {
  options(scipen = 999)
  # 1. Check input data
  if (!is.list(data)) {
    stop("Input data is not a list format!")
  }
  # 2. Extract dose.response.mats
  if (adjusted) {
    if ("adjusted.response.mats" %in% names(data)) {
      dose.response.mats <- data$adjusted.response.mats
    } else {
      stop("The element 'adjusted.response.mats' is missing in input data.")
    }
  } else {
    dose.response.mats <- data$dose.response.mats
  }
  
  blocks <- names(dose.response.mats)
  
  # Generate containers
  # List for saving synergy score matrices
  scores <- vector(mode="list", length=length(blocks))
  names(scores) <- blocks
  
  # 3. Calculate synergy scores
  if(!method %in% c("ZIP", "HSA", "Bliss", "Loewe")) {
    stop("The method parameter can only be one of the following: ZIP, HSA, Bliss
       and Loewe.")
  }
  for (block in blocks) {
    block <- as.character(block)
    response.mat <- dose.response.mats[[block]]
    scores[[block]] <- switch(method,
                              ZIP = ZIP(response.mat),
                              HSA = HSA(response.mat),
                              Bliss = Bliss(response.mat),
                              Loewe = Loewe(response.mat))
  }
  ## 4. Save data into the list
  data$scores <- scores
  data$method <- method
  return(data)
  # clean up
  gc()
}

#' Calculate Delta synergy score based on ZIP model
#'
#' \code{ZIP} calculates the \eqn{\Delta} score matrix from a dose-response 
#' matrix by using Zero Interaction Potency (ZIP) method.
#'
#' @details Zero Interaction Potency (ZIP) is a reference model for evaluating 
#'   the conbimation effect of two drugs. It captures the effect of drug 
#'   combination by comparing the change in the potency of the dose-response 
#'   curves between individual drugs and their combinations. \cr
#'   \cr
#'   The optional arguments \code{drug.col.model}, \code{drug.row.model} are 
#'   designed for reuse the single drug dose response model fitting results, 
#'   if it has been down before. Functions \code{\link{FitDoseResponse}} and 
#'   \code{\link{ExtractSingleDrug}} could be used to calculate these arguments.
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#'   and row name are representing the concerntrations of drug added to column 
#'   and row, respectively. The values in matrix indicate the inhibition rate to
#'   cell growth.
#' @param quiet A logical value. If it is \code{TRUE} then the warning message
#'   will not show during calculation.
#' @param drug.col.model (optional) a character. It indicates the model used for
#'   fitting dose-response curve for drug added to columns.
#' @param drug.row.model (optional) a character. It indicates the model type
#'   used for fitting dose-response curve for drug added to rows.
#' 
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Jing Tang \email{jing.tang@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#' 
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J. (2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.} Comput Struct Biotechnol J, 13:504– 513.}
#' }
#' 
#' @return A matrix of \eqn{\Delta} score calculated via Zero Interaction
#' Potency (ZIP) method.
#'
#' @export
#' 
#' @examples
#' # No single drug fitted modle before
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response.mat <- data$dose.response.mats[[1]]
#' ZIP.score <- ZIP(response.mat)
#' 
#' # Single drug dose response models have been fitted before.
#' drug.row.model <- FitDoseResponse(ExtractSingleDrug(response.mat, dim="row"))
#' drug.col.model <- FitDoseResponse(ExtractSingleDrug(response.mat, dim="col"))
#' 
#' ZIP.score2 <- ZIP(response.mat[-1, -1], drug.col.model=drug.col.model,
#'                  drug.row.model=drug.row.model)
ZIP <- function(response.mat, quiet = TRUE, drug.row.model = NULL, 
                drug.col.model = NULL) {
  if (quiet) {
    options(warn = -1)
  }
  dose_row_mat <- as.numeric(rownames(response.mat))
  dose_col_mat <- as.numeric(colnames(response.mat))
  dose_col <- dose_col_mat[dose_col_mat > 0]
  dose_row <- dose_row_mat[dose_row_mat > 0]
  
  if (is.null(drug.row.model)) {
    drug.row <- ExtractSingleDrug(response.mat, dim = "row")
    drug.row.model <- FitDoseResponse(drug.row)
  }
  drug.row.fit <- stats::predict(drug.row.model, newdata = data.frame(dose = dose_row))

  if (is.null(drug.col.model)) {
    drug.col <- ExtractSingleDrug(response.mat, dim = "col")
    drug.col.model <- FitDoseResponse(drug.col)
  }
  drug.col.fit <- stats::predict(drug.col.model, newdata = data.frame(dose = dose_col))


  n.row <- length(dose_row)
  n.col <- length(dose_col)
  # generate drug_row fitting matrix
  tmp <- data.frame(dose = dose_row)
  updated.col.mat <- response.mat[rownames(response.mat) != "0",
                                  colnames(response.mat) != "0"]

  for (i in 1:n.col) {
    # nonzero concentrations to take the log
    tmp$response <- updated.col.mat[, i]
    if(nrow(tmp) == 1) {
      # # no fitting
      fitted.response <- tmp$response - 10 ^ -10
    } else {
      tmp.min <- drug.col.fit[i]
      tmp.model <- FitDoseResponse(data = tmp, Emin = tmp.min, Emax = 100)
      if (!is.null(tmp.model$convergence)){
        fitted.response <- tmp$response
      } else {
        fitted.response <- suppressWarnings(stats::fitted(tmp.model))
      }
    }

    # if (fitted.inhibition[length(fitted.inhibition)] < 0)
    #  fitted.inhibition[length(fitted.inhibition)] <- tmp.min
    updated.col.mat[, i] <- fitted.response
  }

  # generate drug_col fitting matrix
  tmp <- data.frame(dose = dose_col)
  updated.row.mat <- response.mat[rownames(response.mat) != "0",
                                  colnames(response.mat) != "0"]

  for (i in 1:n.row) {
    # nonzero concentrations to take the log
    tmp$response <- updated.row.mat[i, ]
    if(nrow(tmp) == 1) {
      # # no fitting
      fitted.response <- tmp$response - 10 ^ -10
    } else {
      tmp.min <- drug.row.fit[i]
      tmp.model <- FitDoseResponse(data = tmp, Emin = tmp.min, Emax = 100)
      if (!is.null(tmp.model$convergence)){
        fitted.response <- tmp$response
      } else {
        fitted.response <- suppressWarnings(stats::fitted(tmp.model))
      }
    }
    # if (fitted.inhibition[length(fitted.inhibition)] < 0)
    #  fitted.inhibition[length(fitted.inhibition)] <- tmp.min
    updated.row.mat[i, ] <- fitted.response
  }

  fitted.mat <- (updated.col.mat + updated.row.mat) / 2

  zip.mat <- matrix(nrow = n.row, ncol = n.col)
  for (i in seq_len((n.row))) {
    for (j in seq_len((n.col))) {
      zip.mat[i, j] <- drug.row.fit[i] + drug.col.fit[j] -
        drug.row.fit[i] * drug.col.fit[j] / 100
    }
  }

  delta.mat <- fitted.mat - zip.mat

  # add synergy scores of single drugs into delta.mat
  delta.mat <- cbind(rep(0, nrow(delta.mat)), delta.mat)
  colnames(delta.mat)[1] <- "0"
  delta.mat <- rbind(rep(0, ncol(delta.mat)), delta.mat)
  rownames(delta.mat)[1] <- "0"

  return(delta.mat)
  
  options(warn = 0)
  # clean up
  gc()
}

#' Calculate Bliss synergy score
#'
#' \code{Bliss} calculates the synergy score matrix for a block of
#' drug combination by using a druginteraction reference model introduced by
#' C. I. Bliss in 1939.
#'
#' This model is a reference model for evaluating the combination effect of two
#' drugs. The basic assumption of this model is "The expected effect of two
#' drugs acting independently". 
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#' and row name are representing the concerntrations of drug added to column and
#' row, respectively. The values in matrix indicate the inhibition rate to cell
#' growth.
#'
#' @return A matrix for synergy score calculated via reference model introduced
#' by C. I. Bliss.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J. (2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.} Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{Bliss, C. I. (1939).
#'    \href{https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1744-7348.1939.tb06990.x}{The toxicity of poisons applied jointly.}
#'    Annals of Applied Biology, 26(3):585–615.}
#' }
#'
#' @export
#' 
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' Bliss.score <- Bliss(data$dose.response.mats[[1]])
Bliss <- function (response.mat) {
  drug.row <- response.mat[, 1]
  drug.col <- response.mat[1, ]
  reference.mat <- response.mat
  for (i in 2:nrow(response.mat)) {
    for (j in 2:ncol(response.mat)) {
      reference.mat[i, j] <- drug.row[i] + drug.col[j] -
        drug.row[i] * drug.col[j]/100
    }
  }
  synergy.mat <- response.mat - reference.mat

  return(synergy.mat)

  # clean up
  gc()
}

#' Calculate HSA synergy score
#'
#' \code{HSA} calculates the synergy score matrix for a block of
#' drug combination by using Highest Single Agent (HSA) reference model.
#'
#' This model is a reference model for evaluating the combination effect of two
#' drugs. The basic assumption of this model is "The reference effect of drug
#' combination is the maximal single drug effect".
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#' and row name are representing the concerntrations of drug added to column and
#' row, respectively. The values in matrix indicate the inhibition rate to cell
#' growth.
#'
#' @return A matrix for synergy score calculated via Highest Single Agent (HSA).
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J.(2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.}Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{Berenbaum MC. (1989).
#'    \href{https://www.ncbi.nlm.nih.gov/pubmed/2692037}{What is synergy?}
#'    Pharmacol Rev 1990 Sep;41(3):422.
#'    }
#' }
#'
#' @export
#' 
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' HSA.score <- HSA(data$dose.response.mats[[1]])
HSA <- function(response.mat) {
  drug.row <- response.mat[, 1]
  drug.col <- response.mat[1, ]
  reference.mat <- response.mat
  for (i in 2:nrow(response.mat)) {
    for (j in 2:ncol(response.mat)) {
      reference.mat[i, j] <- max(drug.row[i], drug.col[j])
    }
  }
  synergy.mat <- response.mat - reference.mat

  return(synergy.mat)

  #clean up
  gc()
}

# Four functions to calculate loewe
eq.LL4.LL4 <- function(x, x1, x2, drug.col.par, drug.row.par) {
  x1 / (drug.col.par[4] * (((x - drug.col.par[3]) /
                            (drug.col.par[2] - x)) ^ (1/drug.col.par[1]))) +
    x2 / (drug.row.par[4] * (((x - drug.row.par[3]) /
                              (drug.row.par[2] - x)) ^ (1/drug.row.par[1]))) - 1
}# Eq.8 in the ZIP paper

eq.L4.L4 <- function(x, x1, x2, drug.col.par, drug.row.par) {
  x1 / exp((drug.col.par[4] + log((drug.col.par[3] - x) /
                                    (x - drug.col.par[2])) / drug.col.par[1])) +
    x2 / exp((drug.row.par[4] + log((drug.row.par[3] - x) /
                                  (x - drug.row.par[2])) / drug.row.par[1])) -1
}# x1, x2 to be log scaled

eq.LL4.L4 <- function(x, x1, x2, drug.col.par, drug.row.par) {
  x1 / (drug.col.par[4] * (((x - drug.col.par[3]) /
                              (drug.col.par[2] - x)) ^ (1 / drug.col.par[1]))) +
    x2 / exp((drug.row.par[4] + log((drug.row.par[3] - x) /
                                  (x - drug.row.par[2])) / drug.row.par[1])) -1
}# x2 to be log-scaled

eq.L4.LL4 <- function(x, x1, x2, drug.col.par, drug.row.par) {
  x1 / exp((drug.col.par[4] + log((drug.col.par[3] - x) /
                                    (x - drug.col.par[2])) / drug.col.par[1])) +
    x2 / (drug.row.par[4] * (((x - drug.row.par[3]) /
                            (drug.row.par[2] - x)) ^ (1 / drug.row.par[1]))) - 1
}# x1 to be log-scaled

# function used to calculate loewe if termination code from 'nleqslv' function
# is -10, 1, or 2, which mean:
# * -10 User supplied Jacobian is most likely incorrect.
# * 1 Function criterion is near zero. Convergence of function values has been
# achieved.
# * 2 x-values within tolerance. This means that the relative distance between
# two consecutive x-values is smaller than xtol but that the function value
# criterion is still larger than ftol. Function values may not be near zero;
# therefore the user must check if function values are acceptably small.
#
fun <- function(col_conc, row_conc, drug.par, model) {
  # LL.4, conc must be raw
  if(model == "LL.4") {
    conc = col_conc + row_conc
    (drug.par[3] + drug.par[2] *
        (conc / drug.par[4]) ^ drug.par[1]) /
      (1 + (conc / drug.par[4]) ^ drug.par[1])
  } else if (model == "L.4"){# L.4, conc must be logscaled, ie. log(conc)
    conc = log(col_conc+row_conc)
    (drug.par[2] + (drug.par[3] - drug.par[2]) /
        (1 + exp(drug.par[1] * (conc - drug.par[4]))))
  } else {
    stop("Model type is incorrect. Available values are 'LL.4' or 'L.4' ")
  }
}

#' Calculate Loewe synergy score
#'
#' \code{Loewe} calculates the synergy score matrix from a dose-response matrix
#' by using a druginteraction reference model introduced by Loewe in 1953.
#' 
#' @details Loewe model is a reference model for evaluating the combination 
#' effect of two drugs. The basic assumption of this model is "The referece 
#' effect of drug combination is the expected effect of a drug combined with 
#' itself". \cr
#' \cr
#' The optional arguments \code{drug.col.model}, \code{drug.row.model} are 
#' designed for reuse the single drug dose response model fitting results, 
#' if it has been down before. Functions \code{\link{FitDoseResponse}} and 
#' \code{\link{ExtractSingleDrug}} could be used to calculate these arguments.
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#'   and row name are representing the concerntrations of drug added to column 
#'   and row, respectively. The values in matrix indicate the inhibition rate to
#'   cell growth.
#' @param quiet A logical value. If it is \code{TRUE} then the warning message
#'   will not show during calculation.
#' @param drug.col.model (optional) a character. It indicates the model used for
#'   fitting dose-response curve for drug added to columns.
#' @param drug.row.model (optional) a character. It indicates the model type
#'   used for fitting dose-response curve for drug added to rows.
#' 
#' @return A matrix for Synergy score calculated via reference model introduced
#'   by Loewe, S.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Jing Tang \email{jing.tang@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J.(2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.}Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{[Loewe, 1953] Loewe, S. (1953).
#'    \href{https://www.ncbi.nlm.nih.gov/pubmed/13081480}{The problem of
#'    synergism and antagonism of combined drugs.} Arzneimittelforschung,
#'    3(6):285–290.
#'    }
#' }
#'
#' @export
#' 
#' @examples
#' # No single drug fitted modle before
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response.mat <- data$dose.response.mats[[1]]
#' Loewe.score <- Loewe(response.mat)
#' 
#' # Single drug dose response models have been fitted before.
#' drug.row.model <- FitDoseResponse(ExtractSingleDrug(response.mat, dim="row"))
#' drug.col.model <- FitDoseResponse(ExtractSingleDrug(response.mat, dim="col"))
#' Loewe.score2 <- Loewe(response.mat, drug.col.model=drug.col.model,
#'                      drug.row.model=drug.row.model)
Loewe <- function (response.mat, quiet = TRUE, drug.col.model = NULL,
                            drug.row.model = NULL) {
  if (quiet) {
    options(warn = -1)
  }

  con <- vapply(list(drug.col.model, drug.row.model), is.null, logical(1))

  if (!all(!con)) {
    drug.row <- ExtractSingleDrug(response.mat, dim = "row")
    drug.col <- ExtractSingleDrug(response.mat, dim = "col")
    drug.row.model <- FitDoseResponse(drug.row)
    drug.col.model <- FitDoseResponse(drug.col)
  }
  drug.row.par <- stats::coef(drug.row.model)
  drug.row.type <- FindModelType(drug.row.model)
  drug.col.par <- stats::coef(drug.col.model)
  drug.col.type <- FindModelType(drug.col.model)
  
  # drug.row$dose[drug.row$dose == 0] = 10^-10 # avoid log(0)
  # drug.col$dose[drug.col$dose == 0] = 10^-10 # avoid log(0)

  loewe.mat <- response.mat
  eq <- switch (paste(drug.col.type, drug.row.type),
                "LL.4 LL.4" = eq.LL4.LL4,
                "L.4 L.4"   = eq.L4.L4,
                "LL.4 L.4"  = eq.LL4.L4,
                "L.4 LL.4"  = eq.L4.LL4)

  x <- max(drug.col.par[2], drug.row.par[2]) + 1
  
  dose_col_mat <- as.numeric(colnames(response.mat))
  dose_row_mat <- as.numeric(rownames(response.mat))
  dose_col <- dose_col_mat[dose_col_mat > 0]
  dose_row <- dose_row_mat[dose_row_mat > 0]
  
  for (i in seq_len(length(dose_col))) {
    for (j in seq_len(length(dose_row))) {
      x1 <- dose_col[i]
      x2 <- dose_row[j]

      options(warn = -1)
      slv <- tryCatch({
        slv <- nleqslv::nleqslv(x, eq, method = "Newton", x1=x1, x2=x2,
                                drug.col.par = drug.col.par,
                                drug.row.par = drug.row.par)
        }, error = function(e){
          slv <- list(termcd = 999)
        }
      )

      if (slv$termcd < 3) {
        y.loewe <- slv$x
      } else {
        y.loewe1 <- fun(x1, x2, drug.par = drug.col.par,
                        model = drug.col.type) # x1 col, x2 row
        y.loewe2 <- fun(x1, x2, drug.par = drug.row.par,
                        model = drug.row.type) # x1 col, x2 row
        y.loewe <- max(y.loewe1, y.loewe2)
      }

      loewe.mat[which(dose_row_mat == x2), which(dose_col_mat == x1)] <- 
        ifelse(y.loewe > 100, 100, y.loewe)
        
    }
  }

  synergy.mat <- response.mat - loewe.mat

  # add synergy scores of single drugs into synergy matrix if input combo matrix
  # doesn't contain single drugs
  if (!0 %in% dose_col_mat) {
    synergy.mat <- cbind(rep(0, nrow(synergy.mat)), synergy.mat)
    colnames(synergy.mat)[1] <- "0"
  }
  if (!0 %in% dose_row_mat) {
    synergy.mat <- rbind(rep(0, ncol(synergy.mat)), synergy.mat)
    rownames(synergy.mat)[1] <- "0"
  }
  
  # Output results
  return(synergy.mat)

  options(warn = 0)
  # clean up
  gc()
}
