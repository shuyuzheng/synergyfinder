# TidyComb
# Functions for calculating drug synergy scores.
#
# Functions in this page:
#
# CalculateSynergy: Calculate the synergy scores for drug combinations
# ZIP/Bliss/HSA/Loewe: 4 functions to calculate synergy scores.
# eq.LL4/L4.LL4/L4: 4 functions to calculate loewe score in CalculateLoewe.
# fun: Function used in CalculateLoewe

#' Calculate the synergy scores for drug combinations
#'
#' \code{CalculateSynergy} is the main function for calculating synergy scores
#' based on model(ZIP, Bliss, Loewe, and HSA) fron one dose-response
#' \strong{matrix}.
#'
#' @param data  a list object generated by function \code{\link{ReshapeData}}.
#'
#' @param adjusted a logical value. If it is \code{TRUE}, the
#'   'adjusted.response.mats' will be used to calculate synergy scores. If it is
#'   \code{FALSE}, the raw data ('dose.response.mats') will be used to calculate
#'   synergy scores.
#'
#' @param method a parameter to specify which models to use to calculate the
#'   synergy scores. Choices are "ZIP", "Bliss", "HSA" and "Loewe". Defaults to
#'   "ZIP".
#'
#' @return a list. It contains 4 elements:
#'   \itemize{
#'     \item \strong{dose.response.mats} The original input dose-response matrix
#'     \item \strong{adjusted.response.mats} The dose response matrix adjusted
#'       by functions: \code{\link{AddNoise}}, \code{\link{ImputeNA}}, and
#'       \code{\link{CorrectBaseLine}}.
#'     \item \strong{drug.pairs} a data frame contains the name of the row drug,
#'     the name of the column drug, concentration unit and block IDs.
#'     \item \strong{scores} It contains the modified response value and 4
#'     type of synergy scores of each drug dose response pair.
#'     \item \strong{method} the method used to calculate the synergy scores.
#'  }
#'
#' @author
#'   \itemize{
#'     \item Liye He \email{liye.he@helsinki.fi}
#'     \item Shuyu Zheng \email{shuyu.zheng@helsinki.fi}
#'  }
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' scores <- CalculateSynergy(data)
CalculateSynergy <- function(data, method = "ZIP", adjusted = TRUE) {
  options(scipen = 999)
  # 1. Check the input data
  if (!is.list(data)) {
    stop("Input data is not in list format!")
  }
  if (!all(c("drug.pairs", "response.df") %in% names(data))) {
    stop("Input data should contain at least tow elements: 'drug.pairs' and 
         'response.df'. Please prepare your data with 'ReshapeData' function.")
  }
  if (adjusted & !("response_adj" %in% c(
    colnames(data$response.df),
    colnames(data$replicate.response)
  ))) {
    stop("'adjusted.response.mats' element is required in input data, when
         argument 'adjusted' is setting as TRUE.")
  }

  # 2. Select the dose response table for plotting.
  if (adjusted) {
    response.df <- data$response.df %>%
      dplyr::select(-response) %>%
      dplyr::rename(response = response_adj)
  } else {
    response.df <- data$response.df %>%
      dplyr::select(-response_adj)
  }
  # 3. Calculate synergy scores
  if (!all(method %in% c("ZIP", "HSA", "Bliss", "Loewe"))) {
    stop("The method parameter can only be one of the following: ZIP, HSA, Bliss
       and Loewe.")
  }

  if (data$replicate) { # data with replicate
    reference.table_boot <- Bootstrapping(reference.table_rep[, c("conc1","conc2","response")])
    scores <- repSynergy(response.df, method = method)
  } else { # data without replicate
    blocks <- unique(response.df$block_id)
    scores <- NULL
    for (i in blocks) {
      response <- response.df %>% 
        dplyr::filter(block_id == i) %>% 
        dplyr::select(- block_id)
      if (length(method) == 1) {
        tmp <- eval(call(method, response))
      } else {
        tmp <- lapply(method, function(x) eval(call(x, response)))
        tmp <- tmp %>% 
          purrr::reduce(dplyr::left_join, 
                 by = grep("conc\\d", colnames(response), value = TRUE))
      }
      
      tmp$block_id <- i
      tmp <- dplyr::select(tmp, block_id, dplyr::everything())
      scores <- rbind.data.frame(scores, tmp)
    }
  }

  ## 4. Save data into the list
  data$scores <- scores
  
  return(data)
}

#' Calculate Delta synergy score based on ZIP model
#'
#' \code{ZIP} calculates the \eqn{\Delta} score matrix from a dose-response
#' matrix by using Zero Interaction Potency (ZIP) method.
#'
#' @details Zero Interaction Potency (ZIP) is a reference model for evaluating
#'   the conbimation effect of two drugs. It captures the effect of drug
#'   combination by comparing the change in the potency of the dose-response
#'   curves between individual drugs and their combinations. \cr
#'   \cr
#'   The optional arguments \code{drug.col.model}, \code{drug.row.model} are
#'   designed for reuse the single drug dose response model fitting results,
#'   if it has been down before. Functions \code{\link{FitDoseResponse}} and
#'   \code{\link{ExtractSingleDrug}} could be used to calculate these arguments.
#'
#' @param response A data frame. It must contain the columns: "conc1", "conc2",
#' ..., for the concentration of the combined drugs and "response" for the
#' observed %inhibition at certain combination.
#' @param Emax The expected maximum response value in the 4 parameter 
#' log-logistic model.
#' @param Emin The expected minimum response value in the 4 parameter 
#' log-logistic model.
#' @param quiet A logical value. If it is \code{TRUE} then the warning message
#' will not show during calculation.
#'  
#' @return A data frame containing the concentrations for drugs, reference
#' response, fitted response and synergy score estimated by ZIP model.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Jing Tang \email{jing.tang@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J. (2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.} Comput Struct Biotechnol J, 13:504– 513.}
#' }
#'
#' @export
#'
#' @examples
#' # No single drug fitted modle before
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response <- data$response[data$response$block_id == 1, c("conc1", "conc2", "response")]
#' ZIP.score <- ZIP(response)
#' 
#' # Parallel processing:
#' if (future::supportsMulticore()) {
#'   future::plan(future::multicore)
#' } else {
#'   future::plan(future::multisession)
#' }
#' ZIP(response)
#' # future::plan(sequential) # Turn off the multicore setting
#' 

ZIP <- function(response, Emin = NA, Emax = NA, quiet = TRUE) {
  if (quiet) {
    options(warn = -1)
  }
  # 1. Calculate ZIP reference effect
  
  # Get predicted response for all single drugs
  single.data <- ExtractSingleDrug(response) # single drug dose response data
  single.pred <- lapply(single.data, 
                         function(x) {
                           data.frame(dose = x$dose,
                                      pred = predict(FitDoseResponse(x, Emin = Emin, Emax = Emax)),
                                      stringsAsFactors = FALSE)
                           })
  
  # Calculate the Bliss reference effect (y = 1 - product_all_drug(1-%Inhibition) * 100)
  ref_zip <- expand.grid(lapply(single.pred, function(x) x$dose))
  ref_zip$ref_zip <- apply(
    expand.grid(lapply(single.pred, function(x) x$pred)),
    1, function(x) {
      (1 - prod(1 - x / 100)) * 100
    }
  )
  
  # 2. Calculate ZIP fitted effect
  concs <- grep("conc\\d", colnames(response), value = TRUE)
  response <- purrr::map(concs, function(conc){
    response %>% 
      dplyr::rename(dose = conc) %>% 
      # Group table by conditions, and wrap as a input data for model fitting
      tidyr::nest(any_of(c("dose", "response"))) %>% 
      mutate(pred= furrr::future_map(data , function(x, conc) { # Parallelizable
        condition.baseline <- x$response[which(x$dose == 0)]
        model <- FitDoseResponse(x, Emin = condition.baseline,
                                 Emax = NA) # Fit dose response curve
        pred <- predict(model) # Predict response on corresponding dosage
        return(pred)
      })) %>% 
      unnest() %>% 
      dplyr::rename(!!conc := "dose")
  })
  
  # Take the average of fitted response as the fit_zip
  response <- response %>% 
    purrr::reduce(left_join, by = c(concs, "response")) %>% 
    mutate(fit_zip = rowMeans(select(., starts_with("pred"))))
  
  # 3. Calculate synegy score
  response <- response %>% 
    left_join(ref_zip, by = concs)
  
  # Assign response value to fit_zip in non-combination wells (single drug or DMSO)
  no_comb_rows <- apply(
    response[, grep("conc\\d", colnames(response), value = TRUE)], 1,
    function(x) {
      (length(x) - sum(x == 0)) <= 1
    }
  )
  response$fit_zip[which(no_comb_rows)] <- response$response[which(no_comb_rows)]
  response$ref_zip[which(no_comb_rows)] <- response$response[which(no_comb_rows)]
  
  response <- response %>% 
    mutate(synergy_zip = fit_zip - ref_zip) %>% 
    select(!!concs, fit_zip, ref_zip, synergy_zip)
  
  return(response)
  options(warn = 0)
}

#' Calculate Bliss synergy score
#'
#' \code{Bliss} calculates the synergy score matrix for a block of
#' drug combination by using a druginteraction reference model introduced by
#' C. I. Bliss in 1939.
#'
#' This model is a reference model for evaluating the combination effect of two
#' drugs. The basic assumption of this model is "The expected effect of two
#' drugs acting independently".
#'
#' @param response A data frame. It must contain the columns: "conc1", "conc2",
#' ..., for the concentration of the combined drugs and "response" for the
#' observed %inhibition at certain combination.
#'
#' @return  A data frame containing the concentrations for drugs, reference
#' response and synergy score estimated by Bliss model.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J. (2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.} Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{Bliss, C. I. (1939).
#'    \href{https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1744-7348.1939.tb06990.x}{The toxicity of poisons applied jointly.}
#'    Annals of Applied Biology, 26(3):585–615.}
#' }
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response <- data$response[data$response$block_id == 1, c("conc1", "conc2", "response")]
#' Bliss.score <- Bliss(response)
Bliss <- function(response) {
  # Get all possible combinations of drug dosages
  single.drugs <- ExtractSingleDrug(response = response)
  bliss <- expand.grid(lapply(single.drugs, function(x) x$dose))

  # Calculate the Bliss reference effect (y = 1 - product_all_drug(1-%Inhibition) * 100)
  bliss$ref_bliss <- apply(
    expand.grid(lapply(single.drugs, function(x) x$response)),
    1, function(x) {
      (1 - prod(1 - x / 100)) * 100
    }
  )

  # Calculate Bliss synergy score
  bliss <- response %>%
    dplyr::left_join(bliss, by = grep("conc\\d", colnames(response),
      value = TRUE
    )) %>%
    dplyr::mutate(synergy_bliss = response - ref_bliss)

  # Assign 0 to synergy scores in non-combination wells (single drug or DMSO)
  no_comb_rows <- apply(
    bliss[, grep("conc\\d", colnames(bliss), value = TRUE)], 1,
    function(x) {
      (length(x) - sum(x == 0)) <= 1
    }
  )
  bliss$synergy_bliss[which(no_comb_rows)] <- 0
  bliss <- dplyr::select(bliss, -response)
  return(bliss)
}

#' Calculate HSA synergy score
#'
#' \code{HSA} calculates the synergy score matrix for a block of
#' drug combination by using Highest Single Agent (HSA) reference model.
#'
#' This model is a reference model for evaluating the combination effect of two
#' drugs. The basic assumption of this model is "The reference effect of drug
#' combination is the maximal single drug effect".
#'
#' @param response A data frame. It must contain the columns: "conc1", "conc2",
#' ..., for the concentration of the combined drugs and "response" for the
#' observed %inhibition at certain combination.
#'
#' @return  A data frame containing the concentrations for drugs, reference
#' response and synergy score estimated by HSA model.
#' 
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J.(2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.}Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{Berenbaum MC. (1989).
#'    \href{https://www.ncbi.nlm.nih.gov/pubmed/2692037}{What is synergy?}
#'    Pharmacol Rev 1990 Sep;41(3):422.
#'    }
#' }
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response <- data$response[data$response$block_id == 1, 
#'                           c("conc1", "conc2", "response")]
#' HSA.score <- HSA(response)
HSA <- function(response) {
  
  # Get all possible combinations of drug dosages
  single.drugs <- ExtractSingleDrug(response = response)
  hsa <- expand.grid(lapply(single.drugs, function(x) x$dose))

  # Calculate the HSA reference effect (max effect in all single drugs)
  hsa$ref_hsa <- apply(
    expand.grid(lapply(single.drugs, function(x) x$response)), 1, max)

  # Calculate HSA synergy score
  hsa <- response %>%
    dplyr::left_join(hsa, by = grep("conc\\d", colnames(response),
      value = TRUE
    )) %>%
    dplyr::mutate(synergy_hsa = response - ref_hsa)

  # Assign 0 to synergy scores in non-combination wells
  no_comb_rows <- apply(
    hsa[, grep("conc\\d", colnames(hsa), value = TRUE)], 1,
    function(x) {
      (length(x) - sum(x == 0)) <= 1
    }
  )
  hsa$synergy_hsa[which(no_comb_rows)] <- 0
  hsa <- dplyr::select(hsa, -response)
  return(hsa)
}

#' Calculate Loewe synergy score
#'
#' \code{Loewe} calculates the synergy score matrix from a dose-response matrix
#' by using a druginteraction reference model introduced by Loewe in 1953.
#'
#' @details Loewe model is a reference model for evaluating the combination
#' effect of two drugs. The basic assumption of this model is "The referece
#' effect of drug combination is the expected effect of a drug combined with
#' itself". \cr
#' \cr
#' The optional arguments \code{drug.col.model}, \code{drug.row.model} are
#' designed for reuse the single drug dose response model fitting results,
#' if it has been down before. Functions \code{\link{FitDoseResponse}} and
#' \code{\link{ExtractSingleDrug}} could be used to calculate these arguments.
#'
#' @param response A data frame. It must contain the columns: "conc1", "conc2",
#' ..., for the concentration of the combined drugs and "response" for the
#' observed %inhibition at certain combination.
#' @param Emax The expected maximum response value in the 4 parameter 
#' log-logistic model.
#' @param Emin The expected minimum response value in the 4 parameter 
#' log-logistic model.
#' @param quiet A logical value. If it is \code{TRUE} then the warning message
#'   will not show during calculation.
#'
#' @return A data frame containing the concentrations for drugs, reference
#' response and synergy score estimated by Loewe model.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Jing Tang \email{jing.tang@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @references \itemize{
#'    \item{Yadav B, Wennerberg K, Aittokallio T, Tang J.(2015).
#'    \href{https://doi.org/10.1016/j.csbj.2015.09.001}{Searching for Drug
#'    Synergy in Complex Dose-Response Landscape Using an Interaction Potency
#'    Model.}Comput Struct Biotechnol J, 13:504– 513.}
#'    \item{[Loewe, 1953] Loewe, S. (1953).
#'    \href{https://www.ncbi.nlm.nih.gov/pubmed/13081480}{The problem of
#'    synergism and antagonism of combined drugs.} Arzneimittelforschung,
#'    3(6):285–290.
#'    }
#' }
#'
#' @export
#'
#' @examples
#' data("mathews_screening_data")
#' data <- ReshapeData(mathews_screening_data)
#' response <- data$response[data$response$block_id == 1, 
#'                           c("conc1", "conc2", "response")]
#' Loewe.score <- Loewe(response)
#'
#' )

Loewe <- function(response, Emin = NA, Emax = NA, quiet = TRUE) {
  if (quiet) {
    options(warn = -1)
  }
  
  ndrugs <- ncol(response) - 1
  single.data <- ExtractSingleDrug(response)
  single.model <- lapply(
    single.data,
    function(x) FitDoseResponse(x, Emin = Emin, Emax = Emax)
  )
  single.par <- lapply(single.model, FindModelPar)
  single.type <- lapply(single.model, FindModelType)

  y.loewe <- c()
  dist.loewe <- c()
  for (i in 1:nrow(response)) {
    x <- response[i, c(1:ndrugs)] # concentrations of drugs
    y <- response$response[i] # the observed combination response

    if (length(which(x > 0)) < 2) { # single drugs
      y.loewe[i] <- y
      dist.loewe[i] <- NA
    } else {
      # find the dose of single drugs that achieve the observed combination response
      x_cap <- mapply(function(par, type) .ed(y, par, type),
        par = single.par, type = single.type
      )

      if (all(!is.finite(x_cap))) { # if none of drug achieve the combination response
        # max of the single drug response
        y.loewe[i] <- max(mapply(function(model) {
          PredictModelSpecify(model, sum(x))
        },
        model = single.model
        ))
        dist.loewe[i] <- NA
      } else {
        # determine the minimal distance
        tmp <- .fsolver(x, single.par, single.type, nsteps = 100)
        y.loewe[i] <- tmp$y.loewe
        dist.loewe[i] <- tmp$distance
      }
    }
  }
  response$ref_loewe <- y.loewe
  # response$dist <- dist.loewe
  response$synergy_loewe <- response$response - y.loewe
  response <- dplyr::select(response, -response)
  # Output results as a long table format
  return(response)

  options(warn = 0)
}



# Auxiliary Functions -----------------------------------------------------

# https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane
# For two dimension point x0, the distance to the line w1*x+w2*y+b = 0
# For three dimension point, the distance to the plan w1*x+w2*y+w3*z+b = 0
# Add so on for higher dimensions
.distance <- function(w, b, x0){
  d <- abs(x0 %*% w + b) / sqrt(sum(w^2))
  return(d)
}

# Load more my own functions
# functions to calculate the expected dose (ed) for a given response in % inhibition
.ed.LL4 <- function(y, drug.par){
  res <- drug.par[4] * (((y - drug.par[3]) / (drug.par[2] - y)) ^ (1/drug.par[1]))
  # if NAN it means the response cannot be achieved by the drug, the response 
  # can be either too high or too low for the drug to achieve
  if (is.nan(res) == TRUE){
    res <- ifelse(y > max(drug.par[3], drug.par[2]), 1, -1)*Inf
  }
  return(res)
}

.ed.L4 <- function(y, drug.par) {
  res <- exp((drug.par[4] + log((drug.par[3] - y) /
                                 (y - drug.par[2])) / drug.par[1]))
  if (is.nan(res) == TRUE) {
    res <- ifelse(y > max(drug.par[3], drug.par[2]), 1, -1)*Inf
  }
  return(res)
}

.ed <- function(y, drug.par, drug.type){
  switch(as.character(drug.type), 
         "LL.4" = .ed.LL4(y, drug.par),
         "L.4"  = .ed.L4(y, drug.par))
}

# another equivalent version for L.4 model
# ed.L4 <- function(y, drug.par) {
#   exp(drug.par[4])*((drug.par[3]-y)/(y-drug.par[2]))^(1/drug.par[1])
# }

# functions to calculate the response (in % inhibition) for a given dose %NOT in use
# .f.LL4 <- function (conc, drug.par) {
#   conc <- conc + 10^-10
#   (drug.par[3] + drug.par[2] *
#       (conc / drug.par[4]) ^ drug.par[1]) /
#     (1 + (conc / drug.par[4]) ^ drug.par[1])
# }
# 
# .f.L4 <- function (conc, drug.par) {
#   conc <- conc + 10^-10
#   logconc <- log(conc)
#   (drug.par[2] + (drug.par[3] - drug.par[2]) /
#       (1 + exp(drug.par[1] * (logconc - drug.par[4]))))
# }
# 
# .f <- function(conc, drug.par, drug.type){
#   switch(as.character(drug.type),
#          "LL.4" = .f.LL4(conc, drug.par),
#          "L.4"  = .f.L4(conc, drug.par))
# }

# solve the distance between x and the dose plane
.fsolver <- function(x, drug.par, drug.type, nsteps = 100){
  # x is the concentration vector
  x <- as.matrix(x)
  ndrugs <- length(x)
  dist <- rep(0, nsteps)
  X_test <- mat.or.vec(ndrugs, nsteps)
  # Find the minimal response of all the drugs
  minY <- min(unlist(lapply(drug.par, function(x) min(x[2],x[3])))) 
  # Find the maximal response of all the drugs
  maxY <- max(unlist(lapply(drug.par, function(x) max(x[2],x[3]))))
  Y_test <- seq(minY, maxY, length.out = nsteps) # test nsteps responses
  # Calculateexpected dose at each drug
  for(i in 1:ndrugs){
    X_test[i,] <- unlist(lapply(Y_test, 
                                function(y) .ed(y,drug.par[[i]],drug.type[[i]])))
  }
  # Calculate distance between point x to the expected dose plane
  for(j in 1:nsteps){ 
    dist[j] = .distance(c(1/X_test[,j]), -1, x) # note the sign of -1
  }
  # output the y.loewe corresponding to the minimal distance
  res <- list(y.loewe = Y_test[which(dist == min(dist, na.rm = T))], 
             x.select = X_test[,which(dist == min(dist, na.rm = T))], 
             distance = min(dist, na.rm = T)) 
}

FindModelPar <- function (model){
  # b, c, d, e, 1
  # fitted parameters
  par <- model$fct$fixed
  par[is.na(par)] <- model$coefficients
  if (FindModelType(model) == "L.4"){
    names(par) <- c("b_Hill", "c_Emin", "d_Emax", "e_log(EC50)", "f_Symmetry")
  } else {
    names(par) <- c("b_Hill", "c_Emin", "d_Emax", "e_EC50", "f_Symmetry")
  }
  return(par)
}

Bootstrapping <- function(response){
  # unique dose conditions
  condition = apply(response[, -ncol(response)], 1, function(x) paste(x, collapse = ";"))
  response$condition = condition
  res = data.frame(response%>%group_by(condition)%>%sample_n(1))
  res = res[,-ncol(res)]
}